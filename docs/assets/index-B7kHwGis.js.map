{"version":3,"file":"index-B7kHwGis.js","sources":["../../node_modules/diff/libesm/diff/base.js","../../node_modules/diff/libesm/diff/character.js","../../node_modules/diff/libesm/util/string.js","../../node_modules/diff/libesm/diff/word.js","../../node_modules/diff/libesm/diff/line.js","../../node_modules/diff/libesm/diff/sentence.js","../../node_modules/diff/libesm/diff/css.js","../../node_modules/diff/libesm/diff/json.js","../../node_modules/diff/libesm/diff/array.js","../../packages/diff-text/index.ts"],"sourcesContent":["export default class Diff {\n    diff(oldStr, newStr, \n    // Type below is not accurate/complete - see above for full possibilities - but it compiles\n    options = {}) {\n        let callback;\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        else if ('callback' in options) {\n            callback = options.callback;\n        }\n        // Allow subclasses to massage the input prior to running\n        const oldString = this.castInput(oldStr, options);\n        const newString = this.castInput(newStr, options);\n        const oldTokens = this.removeEmpty(this.tokenize(oldString, options));\n        const newTokens = this.removeEmpty(this.tokenize(newString, options));\n        return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);\n    }\n    diffWithOptionsObj(oldTokens, newTokens, options, callback) {\n        var _a;\n        const done = (value) => {\n            value = this.postProcess(value, options);\n            if (callback) {\n                setTimeout(function () { callback(value); }, 0);\n                return undefined;\n            }\n            else {\n                return value;\n            }\n        };\n        const newLen = newTokens.length, oldLen = oldTokens.length;\n        let editLength = 1;\n        let maxEditLength = newLen + oldLen;\n        if (options.maxEditLength != null) {\n            maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n        }\n        const maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;\n        const abortAfterTimestamp = Date.now() + maxExecutionTime;\n        const bestPath = [{ oldPos: -1, lastComponent: undefined }];\n        // Seed editLength = 0, i.e. the content starts with the same values\n        let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);\n        if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n            // Identity per the equality and tokenizer\n            return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));\n        }\n        // Once we hit the right edge of the edit graph on some diagonal k, we can\n        // definitely reach the end of the edit graph in no more than k edits, so\n        // there's no point in considering any moves to diagonal k+1 any more (from\n        // which we're guaranteed to need at least k+1 more edits).\n        // Similarly, once we've reached the bottom of the edit graph, there's no\n        // point considering moves to lower diagonals.\n        // We record this fact by setting minDiagonalToConsider and\n        // maxDiagonalToConsider to some finite value once we've hit the edge of\n        // the edit graph.\n        // This optimization is not faithful to the original algorithm presented in\n        // Myers's paper, which instead pointlessly extends D-paths off the end of\n        // the edit graph - see page 7 of Myers's paper which notes this point\n        // explicitly and illustrates it with a diagram. This has major performance\n        // implications for some common scenarios. For instance, to compute a diff\n        // where the new text simply appends d characters on the end of the\n        // original text of length n, the true Myers algorithm will take O(n+d^2)\n        // time while this optimization needs only O(n+d) time.\n        let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;\n        // Main worker method. checks all permutations of a given edit length for acceptance.\n        const execEditLength = () => {\n            for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {\n                let basePath;\n                const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];\n                if (removePath) {\n                    // No one else is going to attempt to use this value, clear it\n                    // @ts-expect-error - perf optimisation. This type-violating value will never be read.\n                    bestPath[diagonalPath - 1] = undefined;\n                }\n                let canAdd = false;\n                if (addPath) {\n                    // what newPos will be after we do an insertion:\n                    const addPathNewPos = addPath.oldPos - diagonalPath;\n                    canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n                }\n                const canRemove = removePath && removePath.oldPos + 1 < oldLen;\n                if (!canAdd && !canRemove) {\n                    // If this path is a terminal then prune\n                    // @ts-expect-error - perf optimisation. This type-violating value will never be read.\n                    bestPath[diagonalPath] = undefined;\n                    continue;\n                }\n                // Select the diagonal that we want to branch from. We select the prior\n                // path whose position in the old string is the farthest from the origin\n                // and does not pass the bounds of the diff graph\n                if (!canRemove || (canAdd && removePath.oldPos < addPath.oldPos)) {\n                    basePath = this.addToPath(addPath, true, false, 0, options);\n                }\n                else {\n                    basePath = this.addToPath(removePath, false, true, 1, options);\n                }\n                newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);\n                if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n                    // If we have hit the end of both strings, then we are done\n                    return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;\n                }\n                else {\n                    bestPath[diagonalPath] = basePath;\n                    if (basePath.oldPos + 1 >= oldLen) {\n                        maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n                    }\n                    if (newPos + 1 >= newLen) {\n                        minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n                    }\n                }\n            }\n            editLength++;\n        };\n        // Performs the length of edit iteration. Is a bit fugly as this has to support the\n        // sync and async mode which is never fun. Loops over execEditLength until a value\n        // is produced, or until the edit length exceeds options.maxEditLength (if given),\n        // in which case it will return undefined.\n        if (callback) {\n            (function exec() {\n                setTimeout(function () {\n                    if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n                        return callback(undefined);\n                    }\n                    if (!execEditLength()) {\n                        exec();\n                    }\n                }, 0);\n            }());\n        }\n        else {\n            while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n                const ret = execEditLength();\n                if (ret) {\n                    return ret;\n                }\n            }\n        }\n    }\n    addToPath(path, added, removed, oldPosInc, options) {\n        const last = path.lastComponent;\n        if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: { count: last.count + 1, added: added, removed: removed, previousComponent: last.previousComponent }\n            };\n        }\n        else {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: { count: 1, added: added, removed: removed, previousComponent: last }\n            };\n        }\n    }\n    extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {\n        const newLen = newTokens.length, oldLen = oldTokens.length;\n        let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;\n        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {\n            newPos++;\n            oldPos++;\n            commonCount++;\n            if (options.oneChangePerToken) {\n                basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };\n            }\n        }\n        if (commonCount && !options.oneChangePerToken) {\n            basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };\n        }\n        basePath.oldPos = oldPos;\n        return newPos;\n    }\n    equals(left, right, options) {\n        if (options.comparator) {\n            return options.comparator(left, right);\n        }\n        else {\n            return left === right\n                || (!!options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n        }\n    }\n    removeEmpty(array) {\n        const ret = [];\n        for (let i = 0; i < array.length; i++) {\n            if (array[i]) {\n                ret.push(array[i]);\n            }\n        }\n        return ret;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    castInput(value, options) {\n        return value;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    tokenize(value, options) {\n        return Array.from(value);\n    }\n    join(chars) {\n        // Assumes ValueT is string, which is the case for most subclasses.\n        // When it's false, e.g. in diffArrays, this method needs to be overridden (e.g. with a no-op)\n        // Yes, the casts are verbose and ugly, because this pattern - of having the base class SORT OF\n        // assume tokens and values are strings, but not completely - is weird and janky.\n        return chars.join('');\n    }\n    postProcess(changeObjects, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    options) {\n        return changeObjects;\n    }\n    get useLongestToken() {\n        return false;\n    }\n    buildValues(lastComponent, newTokens, oldTokens) {\n        // First we convert our linked list of components in reverse order to an\n        // array in the right order:\n        const components = [];\n        let nextComponent;\n        while (lastComponent) {\n            components.push(lastComponent);\n            nextComponent = lastComponent.previousComponent;\n            delete lastComponent.previousComponent;\n            lastComponent = nextComponent;\n        }\n        components.reverse();\n        const componentLen = components.length;\n        let componentPos = 0, newPos = 0, oldPos = 0;\n        for (; componentPos < componentLen; componentPos++) {\n            const component = components[componentPos];\n            if (!component.removed) {\n                if (!component.added && this.useLongestToken) {\n                    let value = newTokens.slice(newPos, newPos + component.count);\n                    value = value.map(function (value, i) {\n                        const oldValue = oldTokens[oldPos + i];\n                        return oldValue.length > value.length ? oldValue : value;\n                    });\n                    component.value = this.join(value);\n                }\n                else {\n                    component.value = this.join(newTokens.slice(newPos, newPos + component.count));\n                }\n                newPos += component.count;\n                // Common case\n                if (!component.added) {\n                    oldPos += component.count;\n                }\n            }\n            else {\n                component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));\n                oldPos += component.count;\n            }\n        }\n        return components;\n    }\n}\n","import Diff from './base.js';\nclass CharacterDiff extends Diff {\n}\nexport const characterDiff = new CharacterDiff();\nexport function diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n}\n","export function longestCommonPrefix(str1, str2) {\n    let i;\n    for (i = 0; i < str1.length && i < str2.length; i++) {\n        if (str1[i] != str2[i]) {\n            return str1.slice(0, i);\n        }\n    }\n    return str1.slice(0, i);\n}\nexport function longestCommonSuffix(str1, str2) {\n    let i;\n    // Unlike longestCommonPrefix, we need a special case to handle all scenarios\n    // where we return the empty string since str1.slice(-0) will return the\n    // entire string.\n    if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {\n        return '';\n    }\n    for (i = 0; i < str1.length && i < str2.length; i++) {\n        if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {\n            return str1.slice(-i);\n        }\n    }\n    return str1.slice(-i);\n}\nexport function replacePrefix(string, oldPrefix, newPrefix) {\n    if (string.slice(0, oldPrefix.length) != oldPrefix) {\n        throw Error(`string ${JSON.stringify(string)} doesn't start with prefix ${JSON.stringify(oldPrefix)}; this is a bug`);\n    }\n    return newPrefix + string.slice(oldPrefix.length);\n}\nexport function replaceSuffix(string, oldSuffix, newSuffix) {\n    if (!oldSuffix) {\n        return string + newSuffix;\n    }\n    if (string.slice(-oldSuffix.length) != oldSuffix) {\n        throw Error(`string ${JSON.stringify(string)} doesn't end with suffix ${JSON.stringify(oldSuffix)}; this is a bug`);\n    }\n    return string.slice(0, -oldSuffix.length) + newSuffix;\n}\nexport function removePrefix(string, oldPrefix) {\n    return replacePrefix(string, oldPrefix, '');\n}\nexport function removeSuffix(string, oldSuffix) {\n    return replaceSuffix(string, oldSuffix, '');\n}\nexport function maximumOverlap(string1, string2) {\n    return string2.slice(0, overlapCount(string1, string2));\n}\n// Nicked from https://stackoverflow.com/a/60422853/1709587\nfunction overlapCount(a, b) {\n    // Deal with cases where the strings differ in length\n    let startA = 0;\n    if (a.length > b.length) {\n        startA = a.length - b.length;\n    }\n    let endB = b.length;\n    if (a.length < b.length) {\n        endB = a.length;\n    }\n    // Create a back-reference for each index\n    //   that should be followed in case of a mismatch.\n    //   We only need B to make these references:\n    const map = Array(endB);\n    let k = 0; // Index that lags behind j\n    map[0] = 0;\n    for (let j = 1; j < endB; j++) {\n        if (b[j] == b[k]) {\n            map[j] = map[k]; // skip over the same character (optional optimisation)\n        }\n        else {\n            map[j] = k;\n        }\n        while (k > 0 && b[j] != b[k]) {\n            k = map[k];\n        }\n        if (b[j] == b[k]) {\n            k++;\n        }\n    }\n    // Phase 2: use these references while iterating over A\n    k = 0;\n    for (let i = startA; i < a.length; i++) {\n        while (k > 0 && a[i] != b[k]) {\n            k = map[k];\n        }\n        if (a[i] == b[k]) {\n            k++;\n        }\n    }\n    return k;\n}\n/**\n * Returns true if the string consistently uses Windows line endings.\n */\nexport function hasOnlyWinLineEndings(string) {\n    return string.includes('\\r\\n') && !string.startsWith('\\n') && !string.match(/[^\\r]\\n/);\n}\n/**\n * Returns true if the string consistently uses Unix line endings.\n */\nexport function hasOnlyUnixLineEndings(string) {\n    return !string.includes('\\r\\n') && string.includes('\\n');\n}\nexport function trailingWs(string) {\n    // Yes, this looks overcomplicated and dumb - why not replace the whole function with\n    //     return string match(/\\s*$/)[0]\n    // you ask? Because:\n    // 1. the trap described at https://markamery.com/blog/quadratic-time-regexes/ would mean doing\n    //    this would cause this function to take O(n²) time in the worst case (specifically when\n    //    there is a massive run of NON-TRAILING whitespace in `string`), and\n    // 2. the fix proposed in the same blog post, of using a negative lookbehind, is incompatible\n    //    with old Safari versions that we'd like to not break if possible (see\n    //    https://github.com/kpdecker/jsdiff/pull/550)\n    // It feels absurd to do this with an explicit loop instead of a regex, but I really can't see a\n    // better way that doesn't result in broken behaviour.\n    let i;\n    for (i = string.length - 1; i >= 0; i--) {\n        if (!string[i].match(/\\s/)) {\n            break;\n        }\n    }\n    return string.substring(i + 1);\n}\nexport function leadingWs(string) {\n    // Thankfully the annoying considerations described in trailingWs don't apply here:\n    const match = string.match(/^\\s*/);\n    return match ? match[0] : '';\n}\n","import Diff from './base.js';\nimport { longestCommonPrefix, longestCommonSuffix, replacePrefix, replaceSuffix, removePrefix, removeSuffix, maximumOverlap, leadingWs, trailingWs } from '../util/string.js';\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nconst extendedWordChars = 'a-zA-Z0-9_\\\\u{C0}-\\\\u{FF}\\\\u{D8}-\\\\u{F6}\\\\u{F8}-\\\\u{2C6}\\\\u{2C8}-\\\\u{2D7}\\\\u{2DE}-\\\\u{2FF}\\\\u{1E00}-\\\\u{1EFF}';\n// Each token is one of the following:\n// - A punctuation mark plus the surrounding whitespace\n// - A word plus the surrounding whitespace\n// - Pure whitespace (but only in the special case where this the entire text\n//   is just whitespace)\n//\n// We have to include surrounding whitespace in the tokens because the two\n// alternative approaches produce horribly broken results:\n// * If we just discard the whitespace, we can't fully reproduce the original\n//   text from the sequence of tokens and any attempt to render the diff will\n//   get the whitespace wrong.\n// * If we have separate tokens for whitespace, then in a typical text every\n//   second token will be a single space character. But this often results in\n//   the optimal diff between two texts being a perverse one that preserves\n//   the spaces between words but deletes and reinserts actual common words.\n//   See https://github.com/kpdecker/jsdiff/issues/160#issuecomment-1866099640\n//   for an example.\n//\n// Keeping the surrounding whitespace of course has implications for .equals\n// and .join, not just .tokenize.\n// This regex does NOT fully implement the tokenization rules described above.\n// Instead, it gives runs of whitespace their own \"token\". The tokenize method\n// then handles stitching whitespace tokens onto adjacent word or punctuation\n// tokens.\nconst tokenizeIncludingWhitespace = new RegExp(`[${extendedWordChars}]+|\\\\s+|[^${extendedWordChars}]`, 'ug');\nclass WordDiff extends Diff {\n    equals(left, right, options) {\n        if (options.ignoreCase) {\n            left = left.toLowerCase();\n            right = right.toLowerCase();\n        }\n        return left.trim() === right.trim();\n    }\n    tokenize(value, options = {}) {\n        let parts;\n        if (options.intlSegmenter) {\n            const segmenter = options.intlSegmenter;\n            if (segmenter.resolvedOptions().granularity != 'word') {\n                throw new Error('The segmenter passed must have a granularity of \"word\"');\n            }\n            parts = Array.from(segmenter.segment(value), segment => segment.segment);\n        }\n        else {\n            parts = value.match(tokenizeIncludingWhitespace) || [];\n        }\n        const tokens = [];\n        let prevPart = null;\n        parts.forEach(part => {\n            if ((/\\s/).test(part)) {\n                if (prevPart == null) {\n                    tokens.push(part);\n                }\n                else {\n                    tokens.push(tokens.pop() + part);\n                }\n            }\n            else if (prevPart != null && (/\\s/).test(prevPart)) {\n                if (tokens[tokens.length - 1] == prevPart) {\n                    tokens.push(tokens.pop() + part);\n                }\n                else {\n                    tokens.push(prevPart + part);\n                }\n            }\n            else {\n                tokens.push(part);\n            }\n            prevPart = part;\n        });\n        return tokens;\n    }\n    join(tokens) {\n        // Tokens being joined here will always have appeared consecutively in the\n        // same text, so we can simply strip off the leading whitespace from all the\n        // tokens except the first (and except any whitespace-only tokens - but such\n        // a token will always be the first and only token anyway) and then join them\n        // and the whitespace around words and punctuation will end up correct.\n        return tokens.map((token, i) => {\n            if (i == 0) {\n                return token;\n            }\n            else {\n                return token.replace((/^\\s+/), '');\n            }\n        }).join('');\n    }\n    postProcess(changes, options) {\n        if (!changes || options.oneChangePerToken) {\n            return changes;\n        }\n        let lastKeep = null;\n        // Change objects representing any insertion or deletion since the last\n        // \"keep\" change object. There can be at most one of each.\n        let insertion = null;\n        let deletion = null;\n        changes.forEach(change => {\n            if (change.added) {\n                insertion = change;\n            }\n            else if (change.removed) {\n                deletion = change;\n            }\n            else {\n                if (insertion || deletion) { // May be false at start of text\n                    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);\n                }\n                lastKeep = change;\n                insertion = null;\n                deletion = null;\n            }\n        });\n        if (insertion || deletion) {\n            dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);\n        }\n        return changes;\n    }\n}\nexport const wordDiff = new WordDiff();\nexport function diffWords(oldStr, newStr, options) {\n    // This option has never been documented and never will be (it's clearer to\n    // just call `diffWordsWithSpace` directly if you need that behavior), but\n    // has existed in jsdiff for a long time, so we retain support for it here\n    // for the sake of backwards compatibility.\n    if ((options === null || options === void 0 ? void 0 : options.ignoreWhitespace) != null && !options.ignoreWhitespace) {\n        return diffWordsWithSpace(oldStr, newStr, options);\n    }\n    return wordDiff.diff(oldStr, newStr, options);\n}\nfunction dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {\n    // Before returning, we tidy up the leading and trailing whitespace of the\n    // change objects to eliminate cases where trailing whitespace in one object\n    // is repeated as leading whitespace in the next.\n    // Below are examples of the outcomes we want here to explain the code.\n    // I=insert, K=keep, D=delete\n    // 1. diffing 'foo bar baz' vs 'foo baz'\n    //    Prior to cleanup, we have K:'foo ' D:' bar ' K:' baz'\n    //    After cleanup, we want:   K:'foo ' D:'bar ' K:'baz'\n    //\n    // 2. Diffing 'foo bar baz' vs 'foo qux baz'\n    //    Prior to cleanup, we have K:'foo ' D:' bar ' I:' qux ' K:' baz'\n    //    After cleanup, we want K:'foo ' D:'bar' I:'qux' K:' baz'\n    //\n    // 3. Diffing 'foo\\nbar baz' vs 'foo baz'\n    //    Prior to cleanup, we have K:'foo ' D:'\\nbar ' K:' baz'\n    //    After cleanup, we want K'foo' D:'\\nbar' K:' baz'\n    //\n    // 4. Diffing 'foo baz' vs 'foo\\nbar baz'\n    //    Prior to cleanup, we have K:'foo\\n' I:'\\nbar ' K:' baz'\n    //    After cleanup, we ideally want K'foo' I:'\\nbar' K:' baz'\n    //    but don't actually manage this currently (the pre-cleanup change\n    //    objects don't contain enough information to make it possible).\n    //\n    // 5. Diffing 'foo   bar baz' vs 'foo  baz'\n    //    Prior to cleanup, we have K:'foo  ' D:'   bar ' K:'  baz'\n    //    After cleanup, we want K:'foo  ' D:' bar ' K:'baz'\n    //\n    // Our handling is unavoidably imperfect in the case where there's a single\n    // indel between keeps and the whitespace has changed. For instance, consider\n    // diffing 'foo\\tbar\\nbaz' vs 'foo baz'. Unless we create an extra change\n    // object to represent the insertion of the space character (which isn't even\n    // a token), we have no way to avoid losing information about the texts'\n    // original whitespace in the result we return. Still, we do our best to\n    // output something that will look sensible if we e.g. print it with\n    // insertions in green and deletions in red.\n    // Between two \"keep\" change objects (or before the first or after the last\n    // change object), we can have either:\n    // * A \"delete\" followed by an \"insert\"\n    // * Just an \"insert\"\n    // * Just a \"delete\"\n    // We handle the three cases separately.\n    if (deletion && insertion) {\n        const oldWsPrefix = leadingWs(deletion.value);\n        const oldWsSuffix = trailingWs(deletion.value);\n        const newWsPrefix = leadingWs(insertion.value);\n        const newWsSuffix = trailingWs(insertion.value);\n        if (startKeep) {\n            const commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);\n            startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);\n            deletion.value = removePrefix(deletion.value, commonWsPrefix);\n            insertion.value = removePrefix(insertion.value, commonWsPrefix);\n        }\n        if (endKeep) {\n            const commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);\n            endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);\n            deletion.value = removeSuffix(deletion.value, commonWsSuffix);\n            insertion.value = removeSuffix(insertion.value, commonWsSuffix);\n        }\n    }\n    else if (insertion) {\n        // The whitespaces all reflect what was in the new text rather than\n        // the old, so we essentially have no information about whitespace\n        // insertion or deletion. We just want to dedupe the whitespace.\n        // We do that by having each change object keep its trailing\n        // whitespace and deleting duplicate leading whitespace where\n        // present.\n        if (startKeep) {\n            const ws = leadingWs(insertion.value);\n            insertion.value = insertion.value.substring(ws.length);\n        }\n        if (endKeep) {\n            const ws = leadingWs(endKeep.value);\n            endKeep.value = endKeep.value.substring(ws.length);\n        }\n        // otherwise we've got a deletion and no insertion\n    }\n    else if (startKeep && endKeep) {\n        const newWsFull = leadingWs(endKeep.value), delWsStart = leadingWs(deletion.value), delWsEnd = trailingWs(deletion.value);\n        // Any whitespace that comes straight after startKeep in both the old and\n        // new texts, assign to startKeep and remove from the deletion.\n        const newWsStart = longestCommonPrefix(newWsFull, delWsStart);\n        deletion.value = removePrefix(deletion.value, newWsStart);\n        // Any whitespace that comes straight before endKeep in both the old and\n        // new texts, and hasn't already been assigned to startKeep, assign to\n        // endKeep and remove from the deletion.\n        const newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);\n        deletion.value = removeSuffix(deletion.value, newWsEnd);\n        endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);\n        // If there's any whitespace from the new text that HASN'T already been\n        // assigned, assign it to the start:\n        startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));\n    }\n    else if (endKeep) {\n        // We are at the start of the text. Preserve all the whitespace on\n        // endKeep, and just remove whitespace from the end of deletion to the\n        // extent that it overlaps with the start of endKeep.\n        const endKeepWsPrefix = leadingWs(endKeep.value);\n        const deletionWsSuffix = trailingWs(deletion.value);\n        const overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);\n        deletion.value = removeSuffix(deletion.value, overlap);\n    }\n    else if (startKeep) {\n        // We are at the END of the text. Preserve all the whitespace on\n        // startKeep, and just remove whitespace from the start of deletion to\n        // the extent that it overlaps with the end of startKeep.\n        const startKeepWsSuffix = trailingWs(startKeep.value);\n        const deletionWsPrefix = leadingWs(deletion.value);\n        const overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);\n        deletion.value = removePrefix(deletion.value, overlap);\n    }\n}\nclass WordsWithSpaceDiff extends Diff {\n    tokenize(value) {\n        // Slightly different to the tokenizeIncludingWhitespace regex used above in\n        // that this one treats each individual newline as a distinct tokens, rather\n        // than merging them into other surrounding whitespace. This was requested\n        // in https://github.com/kpdecker/jsdiff/issues/180 &\n        //    https://github.com/kpdecker/jsdiff/issues/211\n        const regex = new RegExp(`(\\\\r?\\\\n)|[${extendedWordChars}]+|[^\\\\S\\\\n\\\\r]+|[^${extendedWordChars}]`, 'ug');\n        return value.match(regex) || [];\n    }\n}\nexport const wordsWithSpaceDiff = new WordsWithSpaceDiff();\nexport function diffWordsWithSpace(oldStr, newStr, options) {\n    return wordsWithSpaceDiff.diff(oldStr, newStr, options);\n}\n","import Diff from './base.js';\nimport { generateOptions } from '../util/params.js';\nclass LineDiff extends Diff {\n    constructor() {\n        super(...arguments);\n        this.tokenize = tokenize;\n    }\n    equals(left, right, options) {\n        // If we're ignoring whitespace, we need to normalise lines by stripping\n        // whitespace before checking equality. (This has an annoying interaction\n        // with newlineIsToken that requires special handling: if newlines get their\n        // own token, then we DON'T want to trim the *newline* tokens down to empty\n        // strings, since this would cause us to treat whitespace-only line content\n        // as equal to a separator between lines, which would be weird and\n        // inconsistent with the documented behavior of the options.)\n        if (options.ignoreWhitespace) {\n            if (!options.newlineIsToken || !left.includes('\\n')) {\n                left = left.trim();\n            }\n            if (!options.newlineIsToken || !right.includes('\\n')) {\n                right = right.trim();\n            }\n        }\n        else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {\n            if (left.endsWith('\\n')) {\n                left = left.slice(0, -1);\n            }\n            if (right.endsWith('\\n')) {\n                right = right.slice(0, -1);\n            }\n        }\n        return super.equals(left, right, options);\n    }\n}\nexport const lineDiff = new LineDiff();\nexport function diffLines(oldStr, newStr, options) {\n    return lineDiff.diff(oldStr, newStr, options);\n}\nexport function diffTrimmedLines(oldStr, newStr, options) {\n    options = generateOptions(options, { ignoreWhitespace: true });\n    return lineDiff.diff(oldStr, newStr, options);\n}\n// Exported standalone so it can be used from jsonDiff too.\nexport function tokenize(value, options) {\n    if (options.stripTrailingCr) {\n        // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n        value = value.replace(/\\r\\n/g, '\\n');\n    }\n    const retLines = [], linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n    // Ignore the final empty token that occurs if the string ends with a new line\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n        linesAndNewlines.pop();\n    }\n    // Merge the content and line separators into single tokens\n    for (let i = 0; i < linesAndNewlines.length; i++) {\n        const line = linesAndNewlines[i];\n        if (i % 2 && !options.newlineIsToken) {\n            retLines[retLines.length - 1] += line;\n        }\n        else {\n            retLines.push(line);\n        }\n    }\n    return retLines;\n}\n","import Diff from './base.js';\nfunction isSentenceEndPunct(char) {\n    return char == '.' || char == '!' || char == '?';\n}\nclass SentenceDiff extends Diff {\n    tokenize(value) {\n        var _a;\n        // If in future we drop support for environments that don't support lookbehinds, we can replace\n        // this entire function with:\n        //     return value.split(/(?<=[.!?])(\\s+|$)/);\n        // but until then, for similar reasons to the trailingWs function in string.ts, we are forced\n        // to do this verbosely \"by hand\" instead of using a regex.\n        const result = [];\n        let tokenStartI = 0;\n        for (let i = 0; i < value.length; i++) {\n            if (i == value.length - 1) {\n                result.push(value.slice(tokenStartI));\n                break;\n            }\n            if (isSentenceEndPunct(value[i]) && value[i + 1].match(/\\s/)) {\n                // We've hit a sentence break - i.e. a punctuation mark followed by whitespace.\n                // We now want to push TWO tokens to the result:\n                // 1. the sentence\n                result.push(value.slice(tokenStartI, i + 1));\n                // 2. the whitespace\n                i = tokenStartI = i + 1;\n                while ((_a = value[i + 1]) === null || _a === void 0 ? void 0 : _a.match(/\\s/)) {\n                    i++;\n                }\n                result.push(value.slice(tokenStartI, i + 1));\n                // Then the next token (a sentence) starts on the character after the whitespace.\n                // (It's okay if this is off the end of the string - then the outer loop will terminate\n                // here anyway.)\n                tokenStartI = i + 1;\n            }\n        }\n        return result;\n    }\n}\nexport const sentenceDiff = new SentenceDiff();\nexport function diffSentences(oldStr, newStr, options) {\n    return sentenceDiff.diff(oldStr, newStr, options);\n}\n","import Diff from './base.js';\nclass CssDiff extends Diff {\n    tokenize(value) {\n        return value.split(/([{}:;,]|\\s+)/);\n    }\n}\nexport const cssDiff = new CssDiff();\nexport function diffCss(oldStr, newStr, options) {\n    return cssDiff.diff(oldStr, newStr, options);\n}\n","import Diff from './base.js';\nimport { tokenize } from './line.js';\nclass JsonDiff extends Diff {\n    constructor() {\n        super(...arguments);\n        this.tokenize = tokenize;\n    }\n    get useLongestToken() {\n        // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n        // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n        return true;\n    }\n    castInput(value, options) {\n        const { undefinedReplacement, stringifyReplacer = (k, v) => typeof v === 'undefined' ? undefinedReplacement : v } = options;\n        return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), null, '  ');\n    }\n    equals(left, right, options) {\n        return super.equals(left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'), options);\n    }\n}\nexport const jsonDiff = new JsonDiff();\nexport function diffJson(oldStr, newStr, options) {\n    return jsonDiff.diff(oldStr, newStr, options);\n}\n// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nexport function canonicalize(obj, stack, replacementStack, replacer, key) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n    if (replacer) {\n        obj = replacer(key === undefined ? '' : key, obj);\n    }\n    let i;\n    for (i = 0; i < stack.length; i += 1) {\n        if (stack[i] === obj) {\n            return replacementStack[i];\n        }\n    }\n    let canonicalizedObj;\n    if ('[object Array]' === Object.prototype.toString.call(obj)) {\n        stack.push(obj);\n        canonicalizedObj = new Array(obj.length);\n        replacementStack.push(canonicalizedObj);\n        for (i = 0; i < obj.length; i += 1) {\n            canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, String(i));\n        }\n        stack.pop();\n        replacementStack.pop();\n        return canonicalizedObj;\n    }\n    if (obj && obj.toJSON) {\n        obj = obj.toJSON();\n    }\n    if (typeof obj === 'object' && obj !== null) {\n        stack.push(obj);\n        canonicalizedObj = {};\n        replacementStack.push(canonicalizedObj);\n        const sortedKeys = [];\n        let key;\n        for (key in obj) {\n            /* istanbul ignore else */\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                sortedKeys.push(key);\n            }\n        }\n        sortedKeys.sort();\n        for (i = 0; i < sortedKeys.length; i += 1) {\n            key = sortedKeys[i];\n            canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack, replacer, key);\n        }\n        stack.pop();\n        replacementStack.pop();\n    }\n    else {\n        canonicalizedObj = obj;\n    }\n    return canonicalizedObj;\n}\n","import Diff from './base.js';\nclass ArrayDiff extends Diff {\n    tokenize(value) {\n        return value.slice();\n    }\n    join(value) {\n        return value;\n    }\n    removeEmpty(value) {\n        return value;\n    }\n}\nexport const arrayDiff = new ArrayDiff();\nexport function diffArrays(oldArr, newArr, options) {\n    return arrayDiff.diff(oldArr, newArr, options);\n}\n","import { diffWords, diffChars, diffWordsWithSpace, diffLines, diffSentences, diffCss, diffJson, diffArrays } from 'diff';\n\n// https://github.com/kpdecker/jsdiff#change-objects\n/**\n * Represents a single change in a diff operation.\n *\n * @property value - The text content associated with this change.\n * @property added - Indicates if this segment was added.\n * @property removed - Indicates if this segment was removed.\n * @property count - The number of characters or items in this change.\n */\ntype ChangeObject = {\n    value: string;\n    added: boolean;\n    removed: boolean;\n    count: number;\n};\n\n/**\n * A mapping of diff mode names to their corresponding diffing functions.\n *\n * Each key represents a diff mode, such as 'word', 'chars', 'lines', etc.,\n * and maps to a function that performs the diff operation for that mode.\n *\n * Available diff modes:\n * - `word`: Diffs by words.\n * - `chars`: Diffs by individual characters.\n * - `wordsWithSpaces`: Diffs by words, preserving spaces.\n * - `lines`: Diffs by lines.\n * - `sentences`: Diffs by sentences.\n * - `css`: Diffs CSS code.\n * - `json`: Diffs JSON objects.\n * - `arrays`: Diffs arrays.\n *\n * @remarks\n * The diffing functions (e.g., `diffWords`, `diffChars`) must be defined and imported in the module.\n */\nconst DIFF_MODES = {\n    word: diffWords,\n    chars: diffChars,\n    wordsWithSpaces: diffWordsWithSpace,\n    lines: diffLines,\n    sentences: diffSentences,\n    css: diffCss,\n    json: diffJson,\n    arrays: diffArrays,\n};\n\ntype DiffMode = keyof typeof DIFF_MODES;\n\ntype DiffTextOptions<FuncType extends (...any) => any> = Parameters<FuncType>[3];\n\ntype AnyDiffOptions = DiffTextOptions<typeof diffWords> | DiffTextOptions<typeof diffChars> | DiffTextOptions<typeof diffWordsWithSpace> | DiffTextOptions<typeof diffLines> | DiffTextOptions<typeof diffSentences> | DiffTextOptions<typeof diffCss> | DiffTextOptions<typeof diffJson> | DiffTextOptions<typeof diffArrays>;\n\n/**\n * A custom HTML element for displaying and updating text differences (\"diffs\") between two sources.\n * \n * The `DiffText` web component compares two text sources (either from attributes, DOM elements, or remote URLs)\n * and renders the differences using customizable diff modes (e.g., word, character, line, or JSON).\n * It supports live updates via MutationObservers or periodic refetching from remote sources.\n * \n * ## Attributes\n * - `original`: CSS selector for the original text element, or direct text value.\n * - `changed`: CSS selector for the changed text element, or direct text value.\n * - `original-src`: URL to fetch the original text from.\n * - `changed-src`: URL to fetch the changed text from.\n * - `refetch`: Interval (in seconds) to periodically refetch remote sources.\n * - `mode`: Diff mode to use (`word`, `char`, `line`, `json`, etc.).\n * - `ignore-case`: If present, performs a case-insensitive diff.\n * - `compare`: Property or attribute name to use for extracting text from elements.\n * \n * ## Properties\n * - `changes`: The current array of diff change objects.\n * - `mode`: The current diff mode.\n * - `ignoreCase`: Whether to ignore case when diffing.\n * - `original`: The original text or selector.\n * - `changed`: The changed text or selector.\n * - `originalSrc`: The URL for the original text.\n * - `changedSrc`: The URL for the changed text.\n * - `refetch`: The refetch interval in seconds.\n * - `compare`: The property or attribute to use for comparison.\n * - `options`: Additional options for the diff algorithm.\n * \n * ## Methods\n * - `refresh()`: Manually refreshes the diff by re-fetching sources and re-rendering.\n * \n * ## Events\n * - Dispatches a `diff-text` CustomEvent whenever the diff changes, with details about the diff and current options.\n * \n * ## Usage Example\n * ```html\n * <diff-text original=\"#old\" changed=\"#new\" mode=\"word\"></diff-text>\n * ```\n * \n * @element diff-text\n * @fires diff-text - Fired when the diff changes.\n * @public\n */\nexport class DiffText extends HTMLElement {\n    static get setupAttrs(): string[] { return ['original-selector', 'changed-selector', 'original-src', 'changed-src', 'refetch']; }\n    static get observedAttributes(): string[] {\n        const jsDiffAttrs = ['mode', 'ignore-case'];\n        return [...jsDiffAttrs, ...DiffText.setupAttrs, 'original', 'changed', 'compare'];\n    }\n\n    #originalMutationObserver: MutationObserver | null = null;\n    #changedMutationObserver: MutationObserver | null = null;\n    #refetchIntervalListener: ReturnType<typeof setInterval> | null = null;\n    #originalValue: string | undefined;\n    #changedValue: string | undefined;\n    #changes: ChangeObject[] = [];\n    #animationFrame: number | null = null;\n    #jsDiffOptions: AnyDiffOptions | null = null;\n\n    get changes(): ChangeObject[] {\n        return this.#changes;\n    }\n\n    get mode(): DiffMode {\n        return (this.getAttribute('mode') || 'word') as DiffMode;\n    }\n\n    set mode(value: DiffMode) {\n        if (!value?.length) {\n            this.setAttribute('mode', value);\n        } else {\n            this.removeAttribute('mode');\n        }\n    }\n\n    get ignoreCase(): boolean {\n        return this.getAttribute('ignore-case') === 'true';\n    }\n\n    set ignoreCase(value: boolean) {\n        if (value) {\n            this.setAttribute('ignore-case', '');\n        } else {\n            this.removeAttribute('ignore-case');\n        }\n    }\n\n    get original(): string {\n        return this.getAttribute('original') || '';\n    }\n\n    set original(value: string) {\n        if (value?.length) {\n            this.setAttribute('original', value);\n        } else {\n            this.removeAttribute('original');\n        }\n    }\n\n    get changed(): string {\n        return this.getAttribute('changed') || '';\n    }\n\n    set changed(value: string) {\n        if (value?.length) {\n            this.setAttribute('changed', value);\n        } else {\n            this.removeAttribute('changed');\n        }\n    }\n\n    get originalSelector(): string {\n        return this.getAttribute('original-selector') || '';\n    }\n\n    set originalSelector(value: string) {\n        if (value?.length) {\n            this.setAttribute('original-selector', value);\n        } else {\n            this.removeAttribute('original-selector');\n        }\n    }\n\n    get changedSelector(): string {\n        return this.getAttribute('changed-selector') || '';\n    }\n\n    set changedSelector(value: string) {\n        if (value?.length) {\n            this.setAttribute('changed-selector', value);\n        } else {\n            this.removeAttribute('changed-selector');\n        }\n    }\n\n    get originalSrc(): string {\n        return this.getAttribute('original-src') || '';\n    }\n\n    set originalSrc(value: string) {\n        if (value?.length) {\n            this.setAttribute('original-src', value);\n        } else {\n            this.removeAttribute('original-src');\n        }\n    }\n\n    get changedSrc(): string {\n        return this.getAttribute('changed-src') || '';\n    }\n\n    set changedSrc(value: string) {\n        if (value?.length) {\n            this.setAttribute('changed-src', value);\n        } else {\n            this.removeAttribute('changed-src');\n        }\n    }\n\n    get refetch(): number | undefined {\n        const refetchAttr = this.getAttribute('refetch');\n        if (refetchAttr) {\n            const refetchNum = parseInt(refetchAttr, 10);\n            if (isNaN(refetchNum) || refetchNum <= 0) {\n                return undefined;\n            }\n            return refetchNum;\n        }\n        return undefined;\n    }\n\n    set refetch(value: string) {\n        if (value?.length) {\n            try {\n                const parsedNum = parseInt(value, 10);\n                if (parsedNum) {\n                    this.setAttribute('refetch', value);\n                } else {\n                    this.removeAttribute('refetch');\n                }\n            } catch (_e) {\n                this.removeAttribute('refetch');\n            }\n        } else {\n            this.removeAttribute('refetch');\n        }\n    }\n\n    get compare(): string | null {\n        return this.getAttribute('compare');\n    }\n\n    set compare(value: string | null) {\n        if (value?.length) {\n            this.setAttribute('compare', value);\n        } else {\n            this.removeAttribute('compare');\n        }\n    }\n\n    constructor() {\n        super();\n    }\n\n    connectedCallback() {\n        this.#setup();\n        this.#render();\n    }\n\n    disconnectedCallback() {\n        this.#originalMutationObserver?.disconnect();\n        this.#originalMutationObserver = null;\n        this.#changedMutationObserver?.disconnect();\n        this.#changedMutationObserver = null;\n        if (this.#refetchIntervalListener) {\n            clearInterval(this.#refetchIntervalListener);\n            this.#refetchIntervalListener = null;\n        }\n    }\n\n    #fetchSrcs() {\n        const originalSrc = this.getAttribute('original-src');\n        const changedSrc = this.getAttribute('changed-src');\n\n        const promises: Promise<number | void>[] = [];\n        const errors: Error[] = [];\n\n        if (originalSrc) {\n            promises.push(fetch(originalSrc)\n                .then(response => {\n                    if (this.mode === 'json') {\n                        return response.json();\n                    }\n                    return response.text();\n                })\n                .then(text => {\n                    this.#originalValue = text;\n                }).catch((e: Error) => errors.push(e)));\n        }\n\n        if (changedSrc) {\n            promises.push(fetch(changedSrc)\n                .then(response => {\n                    if (this.mode === 'json') {\n                        return response.json();\n                    }\n                    return response.text();\n                })\n                .then(text => {\n                    this.#changedValue = text;\n                }).catch((e: Error) => errors.push(e)));\n        }\n\n        //only throw errors after both fetches have been attempted.\n        Promise.allSettled(promises).then(() => {\n            if (errors.length) {\n                console.error('Error fetching diff text sources:');\n                errors.forEach(error => console.error(error));\n            }\n            this.#render();\n        });\n    }\n\n    #getElementValue = (el: HTMLElement): string => {\n        const compareProp = this.compare;\n        if (!compareProp?.length) {\n            return innerText;\n        }\n        const comparePropValue = compareProp in el ? el[compareProp] : null;\n        if (compareProp) {\n            return comparePropValue;\n        }\n        const compareAttrValue = el.getAttribute(compareProp);\n        if (compareAttrValue) {\n            return compareAttrValue;\n        }\n        if (el instanceof DiffText) {\n            const joinChar = this.mode === \"lines\" ? \"\\n\" : \"\";\n            const elText = el.children.filter(child => !child.classList.contains('diff-text-removed').join(joinChar));\n            return elText;\n        }\n        const innerText = el.innerText;\n        return innerText;\n    }\n\n    #setup() {\n        this.disconnectedCallback();\n        const usingOriginalSrc = Boolean(this.getAttribute('original-src'));\n        const usingChangedSrc = Boolean(this.getAttribute('changed-src'));\n        const refetchAttr = this.getAttribute('refetch');\n        const refetchNum = refetchAttr ? parseInt(refetchAttr, 10) : 0\n        const usingRefetch = (usingOriginalSrc || usingChangedSrc) && Boolean(refetchNum);\n\n        const usingOriginalEl = !usingOriginalSrc && Boolean(this.originalSelector);\n        const usingChangedEl = !usingChangedSrc && Boolean(this.changedSelector);\n\n        if (usingOriginalSrc || usingChangedSrc) {\n            this.#fetchSrcs();\n        }\n\n        if (usingRefetch) {\n            if (this.#refetchIntervalListener) {\n                clearInterval(this.#refetchIntervalListener);\n            }\n            if (this.#refetchIntervalListener) {\n                clearInterval(this.#refetchIntervalListener);\n                this.#refetchIntervalListener = null;\n            }\n            this.#refetchIntervalListener = setInterval(() => {\n                this.#fetchSrcs();\n                this.#render();\n            }, Math.max(1000, refetchNum * 1000));\n        }\n\n        const observerOptions = { childList: true, subtree: true, attributes: true, characterData: true };\n        if (usingOriginalEl) {\n            if (this.#originalMutationObserver) {\n                this.#originalMutationObserver.disconnect();\n            } else if (this.originalSelector) {\n                this.#originalMutationObserver = new MutationObserver(() => {\n                    const originalEl = document.querySelector<HTMLElement>(this.originalSelector);\n                    this.#originalValue = this.#getElementValue(originalEl as HTMLElement);\n                    this.#render();\n                });\n            }\n            if (this.originalSelector) {\n                const originalEl = document.querySelector<HTMLElement>(this.originalSelector);\n                if (originalEl) {\n                    this.#originalMutationObserver?.observe(originalEl, observerOptions);\n                    originalEl.addEventListener('input', () => {\n                        this.#originalValue = this.#getElementValue(originalEl as HTMLElement);\n                        this.#render();\n                    });\n                    this.#originalValue = this.#getElementValue(originalEl);\n                }\n            }\n        }\n\n        if (usingChangedEl) {\n            if (this.#changedMutationObserver) {\n                this.#changedMutationObserver.disconnect();\n            } else if (this.changedSelector) {\n                this.#changedMutationObserver = new MutationObserver(() => {\n                    console.log('changed mutation observer');\n                    const changedEl = document.querySelector(this.changedSelector);\n                    this.#changedValue = this.#getElementValue(changedEl as HTMLElement);\n                    this.#render();\n                });\n            }\n            if (this.changedSelector) {\n                const changedEl = document.querySelector<HTMLElement>(this.changedSelector);\n                if (changedEl) {\n                    this.#changedMutationObserver?.observe(changedEl, observerOptions);\n                    changedEl.addEventListener('input', () => {\n                        this.#changedValue = this.#getElementValue(changedEl as HTMLElement);\n                        this.#render();\n                    });\n                    this.#changedValue = this.#getElementValue(changedEl);\n                }\n            }\n        }\n    }\n\n    get options(): AnyDiffOptions {\n        return this.#jsDiffOptions || undefined;\n    }\n\n    set options(newValue: AnyDiffOptions | null | undefined) {\n        if (newValue) {\n            this.#jsDiffOptions = newValue as AnyDiffOptions;\n        } else {\n            this.#jsDiffOptions = null;\n        }\n        this.#render();\n    }\n\n    #updateDiff(): boolean {\n        const modeFn = (DIFF_MODES[this.mode] || diffWords) as Function;\n        const a = this.#originalValue;\n        const b = this.#changedValue;\n        const oldChanges = structuredClone(this.#changes);\n        const newChanges = modeFn(a ?? '', b ?? '', {\n            ignoreCase: Boolean(this.ignoreCase),\n            ...(this.options ?? {}),\n            //the callback cannot be passed as a jsDiff option as this makes the call async\n            //promise.try() could be used here in the future when there's greater usage\n            callback: undefined,\n        }) as ChangeObject[];\n\n        const hasChanged = newChanges.length !== oldChanges.length || newChanges.some((change, index) => {\n            const oldChange = oldChanges[index];\n            return !oldChange || change.value !== oldChange.value || change.added !== oldChange.added || change.removed !== oldChange.removed || change.count !== oldChange.count;\n        });\n\n        if (hasChanged) {\n            this.#changes = newChanges;\n\n            //handling the options callback provides compatibility with the jsDiff API\n            //@ts-expect-error - callback type isn't inferred\n            if (this.options && this.options?.callback && typeof this.options?.callback === 'function') {\n                //@ts-expect-error - callback type isn't inferred\n                this.options?.callback(this.#changes);\n            }\n            const eventDetail = {\n                ...Object.fromEntries(DiffText.observedAttributes.map(attr => {\n                    return [attr, this.getAttribute(attr)];\n                })),\n                options: this.options,\n                original: this.#originalValue,\n                changed: this.#changedValue,\n                changes: this.#changes,\n            }\n            this.dispatchEvent(new CustomEvent('diff-text', {\n                detail: eventDetail,\n                bubbles: true,\n                composed: true,\n                cancelable: true,\n            }));\n        }\n        return hasChanged;\n    }\n\n    #render() {\n        if (this.#animationFrame) {\n            cancelAnimationFrame(this.#animationFrame);\n        }\n        this.#animationFrame = requestAnimationFrame(() => {\n            const changed = this.#updateDiff();\n            if (changed) {\n                this.innerHTML = '';\n                this.#changes.forEach(change => {\n                    const elName = change.added ? 'ins' : change.removed ? 'del' : 'span';\n                    const el = document.createElement(elName);\n                    el.textContent = change.value;\n                    if (change.removed) {\n                        el.setAttribute(\"contenteditable\", \"false\");\n                    }\n                    el.dataset.diffTextCount = change.count.toString();\n                    this.appendChild(el);\n                });\n            }\n        });\n    }\n\n    attributeChangedCallback(name: string, _oldValue: string, newValue: string) {\n        if (name === 'mode' && newValue?.length && !DIFF_MODES[newValue]) {\n            this.setAttribute('mode', 'word');\n            return;\n        }\n        if (name === 'original') {\n            this.#originalValue = newValue;\n        }\n        if (name === 'changed') {\n            this.#changedValue = newValue;\n        }\n        const requiresNewSetup = DiffText.setupAttrs.includes(name);\n        if (requiresNewSetup) {\n            this.#setup();\n        }\n\n        this.#render();\n    }\n\n    refresh() {\n        this.#setup();\n        this.#render();\n    }\n}\n\nif (customElements?.define && !customElements.get('diff-text')) {\n    customElements.define('diff-text', DiffText);\n}\n"],"names":["Diff","oldStr","newStr","options","callback","oldString","newString","oldTokens","newTokens","_a","done","value","newLen","oldLen","editLength","maxEditLength","maxExecutionTime","abortAfterTimestamp","bestPath","newPos","minDiagonalToConsider","maxDiagonalToConsider","execEditLength","diagonalPath","basePath","removePath","addPath","canAdd","addPathNewPos","canRemove","exec","ret","path","added","removed","oldPosInc","last","oldPos","commonCount","left","right","array","i","chars","changeObjects","lastComponent","components","nextComponent","componentLen","componentPos","component","oldValue","CharacterDiff","characterDiff","diffChars","longestCommonPrefix","str1","str2","longestCommonSuffix","replacePrefix","string","oldPrefix","newPrefix","replaceSuffix","oldSuffix","newSuffix","removePrefix","removeSuffix","maximumOverlap","string1","string2","overlapCount","a","b","startA","endB","map","k","j","trailingWs","leadingWs","match","extendedWordChars","tokenizeIncludingWhitespace","WordDiff","parts","segmenter","segment","tokens","prevPart","part","token","changes","lastKeep","insertion","deletion","change","dedupeWhitespaceInChangeObjects","wordDiff","diffWords","diffWordsWithSpace","startKeep","endKeep","oldWsPrefix","oldWsSuffix","newWsPrefix","newWsSuffix","commonWsPrefix","commonWsSuffix","ws","newWsFull","delWsStart","delWsEnd","newWsStart","newWsEnd","endKeepWsPrefix","deletionWsSuffix","overlap","startKeepWsSuffix","deletionWsPrefix","WordsWithSpaceDiff","regex","wordsWithSpaceDiff","LineDiff","tokenize","lineDiff","diffLines","retLines","linesAndNewlines","line","isSentenceEndPunct","char","SentenceDiff","result","tokenStartI","sentenceDiff","diffSentences","CssDiff","cssDiff","diffCss","JsonDiff","undefinedReplacement","stringifyReplacer","v","canonicalize","jsonDiff","diffJson","obj","stack","replacementStack","replacer","key","canonicalizedObj","sortedKeys","ArrayDiff","arrayDiff","diffArrays","oldArr","newArr","DIFF_MODES","_originalMutationObserver","_changedMutationObserver","_refetchIntervalListener","_originalValue","_changedValue","_changes","_animationFrame","_jsDiffOptions","_DiffText_instances","fetchSrcs_fn","_getElementValue","setup_fn","updateDiff_fn","render_fn","_DiffText","__privateAdd","el","compareProp","innerText","comparePropValue","compareAttrValue","joinChar","child","__privateGet","refetchAttr","refetchNum","__privateMethod","_b","__privateSet","newValue","name","_oldValue","originalSrc","changedSrc","promises","errors","response","text","e","error","usingOriginalSrc","usingChangedSrc","usingRefetch","usingOriginalEl","usingChangedEl","observerOptions","originalEl","changedEl","_c","modeFn","oldChanges","newChanges","hasChanged","index","oldChange","eventDetail","attr","elName","DiffText"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}
{"version":3,"file":"index-Cr8JbYof.js","sources":["../../packages/mutative/index.ts"],"sourcesContent":["/**\n * @module\n * This module contains a utility to constantly monitor specific CSS selectors for changes\n * Callback functions may return a boolean to declare whether or not the mutation is valid. Invalid mutations will be reverted after all callbacks for the change have executed.\n *\n * @example\n * ```javascript\n * Mutative.observe(\"p\", (record) => console.log(record));\n * ```\n */\n\ntype ObserverRecord = Record<string, (record: MutationRecord) => (boolean | void)>;\n\n/**\n * Control CSS selector mutation observers.\n */\nexport default class Mutative {\n    static #isObserving = false;\n    static #observerList: ObserverRecord = {};\n    static #mutationFn = (listOfChanges: MutationRecord[]): void => {\n        if (Mutative.#isObserving) {\n            listOfChanges.forEach((mutationRecord: MutationRecord) => {\n                const { addedNodes, removedNodes, nextSibling, previousSibling } = mutationRecord;\n                const affectedNodes = [\n                    ...Array.from(addedNodes),\n                    ...Array.from(removedNodes),\n                    //the target handles attribute and characterData changes\n                    mutationRecord?.target,\n                    // a characterData change won't have a selector since it is text, so the parent is used instead\n                    mutationRecord.type === 'characterData' ? mutationRecord.target?.parentElement : undefined,\n                ];\n                let isValidChange: boolean = true;\n                //every callback is run before changes are potentially undone\n                Object.entries(Mutative.#observerList).forEach(([selector, callback]) => {\n                    const changeMatchesSelector = affectedNodes.some(node => node instanceof Element && node.matches(selector));\n                    if (changeMatchesSelector) {\n                        const callbackResult = callback(mutationRecord);\n                        // void or undefined values are not treated as false when checking validity\n                        if (callbackResult === false) {\n                            isValidChange = false;\n                        }\n                    }\n                });\n                //undo invalid changes\n                if (!isValidChange) {\n                    const { target, type } = mutationRecord;\n                    if (type === \"characterData\") {\n                        mutationRecord.target.textContent = mutationRecord.oldValue;\n                    }\n                    if (type === \"attributes\") {\n                        const { attributeName, oldValue } = mutationRecord;\n                        if (attributeName) {\n                            if (oldValue) {\n                                (target as Element).setAttribute(attributeName, oldValue);\n                            } else {\n                                (target as Element).removeAttribute(attributeName);\n                            }\n                        }\n                    }\n                    if (type === \"childList\") {\n                        addedNodes?.forEach(node => {\n                            target.removeChild(node);\n                        });\n                        if (nextSibling) {\n                            //the removed node was not the last within its parent\n                            removedNodes?.forEach(node => {\n                                target.insertBefore(nextSibling, node);\n                            });\n                        } else if (previousSibling && previousSibling.nextSibling) {\n                            //the removed node was not the first within its parent\n                            removedNodes?.forEach(node => {\n                                target.insertBefore(previousSibling.nextSibling!, node);\n                            });\n                        } else {\n                            //the removed node was the only child within its parent\n                            removedNodes?.forEach(node => {\n                                target.appendChild(node);\n                            });\n                        }\n                    }\n                }\n            });\n        }\n    };\n    static #bodyObserver = new MutationObserver(Mutative.#mutationFn);\n    static #addSelectorObj(newObj: ObserverRecord): void {\n        Object.assign(Mutative.#observerList, newObj);\n    }\n    static #addSelectorFnPair(name, fn): void {\n        const obj = {};\n        obj[name] = fn;\n        Mutative.#addSelectorObj(obj);\n    }\n    /**\n     * Observe at least 1 CSS selector for changes\n     */\n    static observe(selectors?: string | string[], callback?: Function): void {\n        if (!Mutative.#isObserving) {\n            Mutative.#isObserving = true;\n            Mutative.#bodyObserver.observe(document.body, {\n                attributes: true,\n                subtree: true,\n                childList: true,\n                characterData: true,\n                attributeOldValue: true,\n                characterDataOldValue: true,\n            });\n        }\n        if (selectors) {\n            const isString = typeof selectors === \"string\";\n            const isArray = Array.isArray(selectors);\n            if (!isString && !isArray && !(typeof selectors === \"object\")) {\n                throw new Error(\"selectorDict must be string, array, or object\");\n            }\n            if (isString || isArray) {\n                if (typeof callback !== \"function\") {\n                    throw new Error(\"callback must be a function\");\n                }\n                if (isArray) {\n                    selectors.forEach((name) => {\n                        Mutative.#addSelectorFnPair(name, callback);\n                    });\n                } else {\n                    Mutative.#addSelectorFnPair(selectors, callback);\n                }\n            } else {\n                if (\n                    Object.entries(selectors).some(\n                        ([key, fn]) => typeof key !== \"string\" || typeof fn !== \"function\"\n                    )\n                ) {\n                    throw new Error(\"Must be string-function pairs\");\n                }\n                Mutative.#addSelectorObj(selectors);\n            }\n        }\n    }\n    /**\n     * stop observing at least 1 CSS selector for changes\n     */\n    static disconnect(...selectors: string[]): void {\n        //finish mutation callbacks before removing selectors\n        Mutative.#mutationFn(Mutative.#bodyObserver.takeRecords());\n        if (selectors) {\n            let items: Array<string> = [];\n            //allow many types of selectors to be passed to this function\n            const addItems = (selectorQueries) => {\n                selectorQueries.forEach((s) => {\n                    if (s) {\n                        if (Array.isArray(s)) {\n                            s.forEach((i) => addItems(i));\n                        } else if (typeof s === \"string\") {\n                            items.push(s);\n                        } else {\n                            addItems(Object.keys(s));\n                        }\n                    }\n                });\n            };\n            addItems(selectors);\n            //only try to remove items that are actually part of the observer list\n            const observerKeys = Object.keys(Object.create(Mutative.#observerList));\n            items\n                .filter((k) => observerKeys.includes(k))\n                .forEach((k) => {\n                    delete Mutative.#observerList[k];\n                });\n        }\n        //if there are no selectors left or this is a full pause, stop observing anything at all\n        if (!selectors?.length || !Object.keys(Mutative.#observerList)?.length) {\n            Mutative.#isObserving = false;\n            Mutative.#bodyObserver.disconnect();\n        }\n    }\n\n    /**\n     * Takes and returns a list of mutation records from the body observer.\n     *\n     * This method retrieves all the mutation records that have been queued up \n     * by the body observer and returns them as an array. The record queue is emptied in the process.\n     *\n     * @returns {MutationRecord[]} An array of MutationRecord objects.\n     */\n    static takeRecords(): MutationRecord[] {\n        return Array.from(Mutative.#bodyObserver.takeRecords());\n    }\n\n    /**\n     * Indicates whether the Mutative class is currently observing changes.\n     * \n     * @returns {Boolean} True if observing, false otherwise.\n     */\n    static get isObserving(): Boolean {\n        return Mutative.#isObserving;\n    }\n}"],"names":["_isObserving","_observerList","_mutationFn","_bodyObserver","_Mutative_static","addSelectorObj_fn","addSelectorFnPair_fn","_Mutative","selectors","callback","_a","_b","__privateGet","__privateSet","isString","isArray","name","__privateMethod","key","fn","items","addItems","selectorQueries","s","i","observerKeys","k","newObj","obj","__privateAdd","listOfChanges","mutationRecord","addedNodes","removedNodes","nextSibling","previousSibling","affectedNodes","isValidChange","selector","node","target","type","attributeName","oldValue","Mutative"],"mappings":"yXAgBA,IAAAA,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA,MAAqBC,EAArB,MAAqBA,CAAS,CAgF1B,OAAO,QAAQC,EAA+BC,EAA2B,CAhF7E,IAAAC,EAAAC,EA4FQ,GAXKC,EAAAL,EAASP,KACVa,EAAAN,EAASP,EAAe,IACxBY,EAAAL,EAASJ,GAAc,QAAQ,SAAS,KAAM,CAC1C,WAAY,GACZ,QAAS,GACT,UAAW,GACX,cAAe,GACf,kBAAmB,GACnB,sBAAuB,EAAA,CAC1B,GAEDK,EAAW,CACX,MAAMM,EAAW,OAAON,GAAc,SAChCO,EAAU,MAAM,QAAQP,CAAS,EACvC,GAAI,CAACM,GAAY,CAACC,GAAa,OAAOP,GAAc,SAChD,MAAM,IAAI,MAAM,+CAA+C,EAEnE,GAAIM,GAAYC,EAAS,CACrB,GAAI,OAAON,GAAa,WACpB,MAAM,IAAI,MAAM,6BAA6B,EAE7CM,EACAP,EAAU,QAASQ,GAAS,CAvGhD,IAAAN,EAwGwBO,EAAAP,EAAAH,EAASH,EAAAE,GAAT,KAAAI,EAA4BM,EAAMP,EACtC,CAAC,EAEDQ,EAAAP,EAAAH,EAASH,EAAAE,GAAT,KAAAI,EAA4BF,EAAWC,EAE/C,KAAO,CACH,GACI,OAAO,QAAQD,CAAS,EAAE,KACtB,CAAC,CAACU,EAAKC,CAAE,IAAM,OAAOD,GAAQ,UAAY,OAAOC,GAAO,UAAA,EAG5D,MAAM,IAAI,MAAM,+BAA+B,EAEnDF,EAAAN,EAAAJ,EAASH,EAAAC,GAAT,KAAAM,EAAyBH,EAC7B,CACJ,CACJ,CAIA,OAAO,cAAcA,EAA2B,CA5HpD,IAAAE,EAAAC,EA+HQ,GADAC,EAAAF,EAAAH,EAASL,GAAT,KAAAQ,EAAqBE,EAAAL,EAASJ,GAAc,YAAA,GACxCK,EAAW,CACX,IAAIY,EAAuB,CAAA,EAE3B,MAAMC,EAAYC,GAAoB,CAClCA,EAAgB,QAASC,GAAM,CACvBA,IACI,MAAM,QAAQA,CAAC,EACfA,EAAE,QAASC,GAAMH,EAASG,CAAC,CAAC,EACrB,OAAOD,GAAM,SACpBH,EAAM,KAAKG,CAAC,EAEZF,EAAS,OAAO,KAAKE,CAAC,CAAC,EAGnC,CAAC,CACL,EACAF,EAASb,CAAS,EAElB,MAAMiB,EAAe,OAAO,KAAK,OAAO,OAAOb,EAAAL,EAASN,EAAa,CAAC,EACtEmB,EACK,OAAQM,GAAMD,EAAa,SAASC,CAAC,CAAC,EACtC,QAASA,GAAM,CACZ,OAAOd,EAAAL,EAASN,GAAcyB,CAAC,CACnC,CAAC,CACT,EAEI,EAAClB,GAAA,MAAAA,EAAW,SAAU,GAACG,EAAA,OAAO,KAAKC,EAAAL,EAASN,EAAa,IAAlC,MAAAU,EAAqC,WAC5DE,EAAAN,EAASP,EAAe,IACxBY,EAAAL,EAASJ,GAAc,WAAA,EAE/B,CAUA,OAAO,aAAgC,CACnC,OAAO,MAAM,KAAKS,EAAAL,EAASJ,GAAc,aAAa,CAC1D,CAOA,WAAW,aAAuB,CAC9B,OAAOS,EAAAL,EAASP,EACpB,CACJ,EAlLWA,EAAA,YACAC,EAAA,YACAC,EAAA,YAiEAC,EAAA,YApEXC,EAAA,YAqEWC,WAAgBsB,EAA8B,CACjD,OAAO,OAAOf,EAAAL,EAASN,GAAe0B,CAAM,CAChD,EACOrB,EAAA,SAAmBU,EAAMG,EAAU,CAxE9C,IAAAT,EAyEQ,MAAMkB,EAAM,CAAA,EACZA,EAAIZ,CAAI,EAAIG,EACZF,EAAAP,EAAAH,EAASH,EAAAC,GAAT,KAAAK,EAAyBkB,EAC7B,EA5EJC,EAAqBtB,EAArBH,GACIyB,EADiBtB,EACVP,EAAe,IACtB6B,EAFiBtB,EAEVN,EAAgC,CAAA,GACvC4B,EAHiBtB,EAGVL,EAAe4B,GAA0C,CACxDlB,EAAAL,EAASP,IACT8B,EAAc,QAASC,GAAmC,CALtE,IAAArB,EAMgB,KAAM,CAAE,WAAAsB,EAAY,aAAAC,EAAc,YAAAC,EAAa,gBAAAC,GAAoBJ,EAC7DK,EAAgB,CAClB,GAAG,MAAM,KAAKJ,CAAU,EACxB,GAAG,MAAM,KAAKC,CAAY,EAE1BF,GAAA,YAAAA,EAAgB,OAEhBA,EAAe,OAAS,iBAAkBrB,EAAAqB,EAAe,SAAf,YAAArB,EAAuB,cAAgB,MAAA,EAErF,IAAI2B,EAAyB,GAa7B,GAXA,OAAO,QAAQzB,EAAAL,EAASN,EAAa,EAAE,QAAQ,CAAC,CAACqC,EAAU7B,CAAQ,IAAM,CACvC2B,EAAc,KAAKG,GAAQA,aAAgB,SAAWA,EAAK,QAAQD,CAAQ,CAAC,GAE/E7B,EAASsB,CAAc,IAEvB,KACnBM,EAAgB,GAG5B,CAAC,EAEG,CAACA,EAAe,CAChB,KAAM,CAAE,OAAAG,EAAQ,KAAAC,CAAA,EAASV,EAIzB,GAHIU,IAAS,kBACTV,EAAe,OAAO,YAAcA,EAAe,UAEnDU,IAAS,aAAc,CACvB,KAAM,CAAE,cAAAC,EAAe,SAAAC,CAAA,EAAaZ,EAChCW,IACIC,EACCH,EAAmB,aAAaE,EAAeC,CAAQ,EAEvDH,EAAmB,gBAAgBE,CAAa,EAG7D,CACID,IAAS,cACTT,GAAA,MAAAA,EAAY,QAAQO,GAAQ,CACxBC,EAAO,YAAYD,CAAI,CAC3B,GACIL,EAEAD,GAAA,MAAAA,EAAc,QAAQM,GAAQ,CAC1BC,EAAO,aAAaN,EAAaK,CAAI,CACzC,GACOJ,GAAmBA,EAAgB,YAE1CF,GAAA,MAAAA,EAAc,QAAQM,GAAQ,CAC1BC,EAAO,aAAaL,EAAgB,YAAcI,CAAI,CAC1D,GAGAN,GAAA,MAAAA,EAAc,QAAQM,GAAQ,CAC1BC,EAAO,YAAYD,CAAI,CAC3B,GAGZ,CACJ,CAAC,CAET,GACAV,EApEiBtB,EAoEVJ,EAAgB,IAAI,iBAAiBS,EAAAL,EAASL,EAAW,GApEpE,IAAqB0C,EAArBrC"}
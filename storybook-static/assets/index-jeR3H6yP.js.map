{"version":3,"file":"index-jeR3H6yP.js","sources":["../../packages/signal/index.ts"],"sourcesContent":["/**\n * Options for configuring a signal.\n * \n * @typedef {Object} SignalOptions\n * @property {string} name - The name of the signal.\n * @property {boolean} [useSuffix] - Whether to emit the event as `signal-[name]` (true) or just `signal` (false). The name is always included in the event detail.\n * @property {boolean} [bubbles] - Whether the signal bubbles up through the DOM.\n * @property {boolean} [cancelable] - Whether the signal emit event can be canceled.\n */\nexport type SignalOptions = {\n    name?: string;\n    useSuffix?: boolean;\n    bubbles?: boolean;\n    cancelable?: boolean;\n    target?: EventTarget;\n};\ntype ProxyValue<T> = (string extends keyof T ? T[keyof T & string] : any) | (symbol extends keyof T ? T[keyof T & symbol] : any);\ntype EmitArgs<T> = { action: \"set\", prop: string | symbol, oldValue: any, value: any }\n    | { action: \"defineProperty\", prop: string | symbol, attributes: PropertyDescriptor }\n    | { action: \"delete\", prop: string | symbol, oldValue: ProxyValue<T> }\n    | { action: \"setPrototypeOf\", prototype: object | null }\n    | { action: \"data\" };\n\nexport default class Signal<T extends Object = object> extends EventTarget implements ProxyHandler<T> {\n    [x: string | number | symbol]: any; //allows for any key to be dynamically defined\n    private data: T;\n    private options: SignalOptions | undefined;\n\n    constructor(data: T, options?: SignalOptions) {\n        super();\n        this.data = data ?? {};\n        this.options = options;\n        return new Proxy(this.data, this) as unknown as T & Signal<T>;\n    }\n\n    private emit(args: EmitArgs<T>): boolean {\n        const timestamp = Date.now();\n        const { bubbles = true, cancelable = true, name = \"\", useSuffix = false } = this.options ?? {};\n        const eventName = `signal${(useSuffix && name?.length) ? `-${name}` : ''}`;\n        const detail = { ...args, name, timestamp, data: this.data };\n        const event = new CustomEvent(eventName, { bubbles, cancelable, detail });\n        const tgt = this.options?.target;\n        const tgtCanContinue = (tgt && tgt[\"dispatchEvent\"]) ? tgt?.dispatchEvent(event) : false;\n        let superResult: boolean | undefined = undefined;\n        if (tgtCanContinue) {\n            superResult = super.dispatchEvent(event);\n        }\n        return tgtCanContinue ? (superResult ?? true) : false;\n    }\n\n    get(_target: T, property: string | symbol, receiver: any): ProxyValue<T> {\n        if (property === \"addEventListener\" || property === \"removeEventListener\") {\n            return Reflect.get(EventTarget.prototype, property, this).bind(this);\n        } else { }\n        return Reflect.get(this.data, property, receiver);\n    }\n\n    set(_target: T, prop: string | symbol, value: any, receiver: any): boolean {\n        const oldValue = Reflect.get(this.data, prop, receiver);\n        const isSuccessful = Reflect.set(this.data, prop, value, receiver);\n        if (isSuccessful) {\n            this.emit({ action: \"set\", prop, oldValue, value });\n        }\n        return isSuccessful;\n    }\n\n    deleteProperty(_target: T, prop: string | symbol): boolean {\n        const oldValue = Reflect.get(this.data, prop);\n        const result = Reflect.deleteProperty(this.data, prop);\n        if (result) {\n            this.emit({ action: \"delete\", prop, oldValue });\n        }\n        return result;\n    }\n\n    defineProperty(_target: T, prop: string | symbol, attributes: PropertyDescriptor): boolean {\n        const isSuccessful = Reflect.defineProperty(this.data, prop, attributes);\n        if (isSuccessful) {\n            this.emit({ action: \"defineProperty\", prop, attributes });\n        }\n        return isSuccessful;\n    }\n\n    setPrototypeOf(_target: T, prototype: object | null): boolean {\n        const isSuccessful = Reflect.setPrototypeOf(this.data, prototype);\n        if (isSuccessful) {\n            this.emit({ action: \"setPrototypeOf\", prototype });\n        }\n        return isSuccessful;\n    }\n}"],"names":["Signal","data","options","args","_a","timestamp","bubbles","cancelable","name","useSuffix","eventName","detail","event","tgt","tgtCanContinue","superResult","_target","property","receiver","prop","value","oldValue","isSuccessful","result","attributes","prototype"],"mappings":"AAuBA,MAAqBA,UAA0C,WAAuC,CAKlG,YAAYC,EAASC,EAAyB,CACpC,aAAA,EACD,KAAA,KAAOD,GAAQ,CAAC,EACrB,KAAK,QAAUC,EACR,IAAI,MAAM,KAAK,KAAM,IAAI,CAAA,CAG5B,KAAKC,EAA4B,CAZ7C,IAAAC,EAac,MAAAC,EAAY,KAAK,IAAI,EACrB,CAAE,QAAAC,EAAU,GAAM,WAAAC,EAAa,GAAM,KAAAC,EAAO,GAAI,UAAAC,EAAY,EAAM,EAAI,KAAK,SAAW,CAAC,EACvFC,EAAY,SAAUD,IAAaD,GAAA,MAAAA,EAAM,QAAU,IAAIA,CAAI,GAAK,EAAE,GAClEG,EAAS,CAAE,GAAGR,EAAM,KAAAK,EAAM,UAAAH,EAAW,KAAM,KAAK,IAAK,EACrDO,EAAQ,IAAI,YAAYF,EAAW,CAAE,QAAAJ,EAAS,WAAAC,EAAY,OAAAI,EAAQ,EAClEE,GAAMT,EAAA,KAAK,UAAL,YAAAA,EAAc,OACpBU,EAAkBD,GAAOA,EAAI,cAAoBA,GAAA,YAAAA,EAAK,cAAcD,GAAS,GACnF,IAAIG,EACJ,OAAID,IACcC,EAAA,MAAM,cAAcH,CAAK,GAEpCE,EAAkBC,GAAe,GAAQ,EAAA,CAGpD,IAAIC,EAAYC,EAA2BC,EAA8B,CACjE,OAAAD,IAAa,oBAAsBA,IAAa,sBACzC,QAAQ,IAAI,YAAY,UAAWA,EAAU,IAAI,EAAE,KAAK,IAAI,EAEhE,QAAQ,IAAI,KAAK,KAAMA,EAAUC,CAAQ,CAAA,CAGpD,IAAIF,EAAYG,EAAuBC,EAAYF,EAAwB,CACvE,MAAMG,EAAW,QAAQ,IAAI,KAAK,KAAMF,EAAMD,CAAQ,EAChDI,EAAe,QAAQ,IAAI,KAAK,KAAMH,EAAMC,EAAOF,CAAQ,EACjE,OAAII,GACA,KAAK,KAAK,CAAE,OAAQ,MAAO,KAAAH,EAAM,SAAAE,EAAU,MAAAD,EAAO,EAE/CE,CAAA,CAGX,eAAeN,EAAYG,EAAgC,CACvD,MAAME,EAAW,QAAQ,IAAI,KAAK,KAAMF,CAAI,EACtCI,EAAS,QAAQ,eAAe,KAAK,KAAMJ,CAAI,EACrD,OAAII,GACA,KAAK,KAAK,CAAE,OAAQ,SAAU,KAAAJ,EAAM,SAAAE,EAAU,EAE3CE,CAAA,CAGX,eAAeP,EAAYG,EAAuBK,EAAyC,CACvF,MAAMF,EAAe,QAAQ,eAAe,KAAK,KAAMH,EAAMK,CAAU,EACvE,OAAIF,GACA,KAAK,KAAK,CAAE,OAAQ,iBAAkB,KAAAH,EAAM,WAAAK,EAAY,EAErDF,CAAA,CAGX,eAAeN,EAAYS,EAAmC,CAC1D,MAAMH,EAAe,QAAQ,eAAe,KAAK,KAAMG,CAAS,EAChE,OAAIH,GACA,KAAK,KAAK,CAAE,OAAQ,iBAAkB,UAAAG,EAAW,EAE9CH,CAAA,CAEf"}